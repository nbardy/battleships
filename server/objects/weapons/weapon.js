// Generated by CoffeeScript 1.6.1
(function() {
  var closest, distance, new_projectile_type, render, update;

  new_projectile_type = require('./projectile.js');

  distance = function(item1, item2) {
    var xpart, ypart;
    xpart = Math.pow(item1.position.x - item2.position.x, 2);
    ypart = Math.pow(item1.position.y - item2.position.y, 2);
    return Math.sqrt(xpart + ypart);
  };

  closest = function(launcher, targets) {
    var closest_distance, closest_target, is_closer, is_not_attached, target, this_distance, _i, _len;
    closest_distance = Number.MAX_VALUE;
    for (_i = 0, _len = targets.length; _i < _len; _i++) {
      target = targets[_i];
      this_distance = distance(launcher, target);
      is_closer = this_distance < closest_distance;
      is_not_attached = !(launcher.attached_to === target);
      if (is_closer && is_not_attached) {
        closest_target = target;
        closest_distance = this_distance;
      }
    }
    return closest_target;
  };

  render = void 0;

  update = function(dt, state) {
    var closest_target, new_projectile;
    if (((this.attached_to != null) && this.attached_to.health) <= 0) {
      return [];
    }
    this.cooldown = this.cooldown - dt;
    if (this.cooldown < 0) {
      this.cooldown = 0;
    }
    closest_target = closest(this, state.targetables);
    if (this.cooldown === 0 && (closest_target != null) && distance(this, closest_target) <= this.range) {
      new_projectile = this.fire_projectile({
        x: this.position.x,
        y: this.position.y
      }, closest_target);
      this.cooldown = this.rate;
    }
    return [this].concat(new_projectile || []);
  };

  module.exports = function(options) {
    if (options == null) {
      options = {};
    }
    return function(position) {
      if (position == null) {
        position = {};
      }
      return {
        type: 'weapon',
        range: options.range || 50,
        rate: options.rate || 10,
        acceleration: options.acceleration || 0,
        update: update,
        cooldown: 0,
        position: {
          x: position.x || 0,
          y: position.y || 0
        },
        fire_projectile: new_projectile_type(options.projectile)
      };
    };
  };

}).call(this);
